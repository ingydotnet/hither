#!/usr/bin/env bash
#
# hither: Database Munging Swiss Army Chainsaw
#
# Copyright (c) 2015 Ingy döt Net

set -e
source "$(cd -P `dirname $BASH_SOURCE` && pwd -P)/../lib/bash+.bash"
bash+:import :std can
use Hither

OPTIONS_SPEC="\
hither [<action>] <options> <arguments>

Try 'hither help' for more help.

Options:
--
h,help      Show the hither usage summary
 
i,in=       Input: File, URL or DB
o,out=      Output: File or DB
f,from=     Input data/database/hither type
t,to=       Output data/datbase/hither type
 
a,action=   Explicit hither action/command verb
w,with=     Alternative methodology for action
 
p,profile=  Shell profile to be sourced
m,metadata= Data file w/ info to make targets
 
q,quiet     Show minimal output
v,verbose   Show verbose output
D,debug     Show maximum DEBUG info
"

main() {
  local OK=0

  init-env
  get-opts "$@"
  set-vars
  check-profile

  if [ -n "$HITHER_ACTION" ]; then
    if can "action:$HITHER_ACTION"; then
      "action:$HITHER_ACTION" "${action_arguments[@]}"
      return
    elif $(type "hither-$HITHER_ACTION" &>/dev/null); then
      "hither-$HITHER_ACTION" "${action_arguments[@]}"
      return
    fi
  fi

  create-action-command
  if $(type "$command" &>/dev/null); then
    "$command" "${action_arguments[@]}"
  else
    error "Unsupported hither action: '$command'\n"
  fi
}

init-env() {
  sha1sum=sha1sum
  shopt_opt='shopt -s nullglob globstar'
  if [[ "$OSTYPE" =~ ^darwin|^freebsd ]]; then
    sha1sum=shasum
    shopt_opt='shopt -s nullglob'
  fi

  assert-command curl cut git grep head ln mv readlink "$sha1sum" tr

  export HITHER_QUIET="${HITHER_QUIET:-false}"
  export HITHER_VERBOSE="${HITHER_VERBOSE:-false}"
  export HITHER_DEBUG="${HITHER_DEBUG:-false}"
}

get-opts() {
  [ $# -eq 0 ] && set -- --help

  eval "$(
    echo "$OPTIONS_SPEC" |
      git rev-parse --parseopt -- "$@" ||
    echo exit $?
  )"

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      -i)
        set-in "$1"
        shift
        ;;
      -o)
        set-out "$1"
        shift
        ;;
      -f)
        export HITHER_FROM="$1"
        shift
        ;;
      -t)
        export HITHER_TO="$1"
        shift
        ;;

      -a)
        export HITHER_ACTION="$1"
        shift
        ;;
      -w)
        export HITHER_WITH="$1"
        shift
        ;;

      -p)
        export HITHER_PROFILE="$1"
        shift
        ;;
      -m)
        export HITHER_METADATA="$1"
        shift
        ;;

      -q) export HITHER_QUIET=true ;;
      -v) export HITHER_VERBOSE=true ;;
      -D) export HITHER_DEBUG=true ;;

      --) break ;;

      *) error "unexpected option '$option'" ;;
    esac
  done

  if [ -z "$HITHER_ACTION" ]; then
    if [ $# -gt 0 ]; then
      HITHER_ACTION="$1"; shift
    fi
  fi

  action_arguments=("$@")
}

set-in() {
  local val="$1"
  export HITHER_IN="$val"
  local in_out=IN
  if [[ "$val" =~ ^https?: ]]; then
    set-export URL "$val"
    set-var-from-ext "$val" IN
  elif [[ "$val" =~ ^([a-z]+):// ]]; then
    set-vars-from-conninfo-uri "$val" IN
  elif [[ "$val" =~ ^.*\.(csv|hmd|hsd|sql)$ ]]; then
    set-vars-from-filename "$val" "${BASH_REMATCH[1]}" IN FROM
  else
    error "Invalid value for '--input=$val'."
  fi
}

set-out() {
  local val="$1"
  export HITHER_OUT="$val"
  local in_out=OUT
  if [[ "$val" =~ ^https?: ]]; then
      error "Can't use URL for output"
  elif [[ "$val" =~ ^([a-z]+):// ]]; then
    set-vars-from-conninfo-uri "$val" OUT
  elif [[ "$val" =~ ^.*\.(csv|hmd|hsd|sql|py)$ ]]; then
    set-vars-from-filename "$val" "${BASH_REMATCH[1]}" OUT TO
  else
    error "Invalid value for '--output=$val'."
  fi
}

set-vars-from-filename() {
  local path="$1" ext="$2" in_out="$3" to_from="$4"
  printf -v "HITHER_$to_from" "$ext"
  export "HITHER_$to_from"
  printf -v "HITHER_$in_out" "$path"
  export "HITHER_$in_out"
}

# http://www.postgresql.org/docs/9.4/static/libpq-connect.html#AEN41094
# postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&...]
set-vars-from-conninfo-uri() {
  local url="$1"
  local in_out="$2"
  local to_from= dbtype=
  [ "$in_out" == IN ] && to_from=HITHER_FROM || to_from=HITHER_TO
  [[ "$val" =~ ^([a-z]+):// ]] || die
  dbtype="${BASH_REMATCH[1]}"
  if [[ "$dbtype" =~ ^(pg|postgres|postgresql)$ ]]; then dbtype=pg
  elif [[ "$dbtype" =~ ^(my|mysql)$ ]]; then dbtype=my
  elif [[ "$dbtype" =~ ^(lite|sqlite)$ ]]; then dbtype=lite
  else
    die "Unknown database type in URI: '$dbtype'"
  fi
  printf -v "$to_from" "$dbtype"
  export "$to_from"
  set-export TYPE "$dbtype"
  url="${url/${BASH_REMATCH[1]}:/}"
  url="${url#//}"
  if [[ "$url" =~ (.*?)@ ]]; then
    url="${url#*@}"
    userpass="${BASH_REMATCH[1]}"
    if [[ "$userpass" =~ ^(.*):(.*)$ ]]; then
      set-export USER "${BASH_REMATCH[1]}"
      set-export PASSWORD "${BASH_REMATCH[2]}"
    else
      set-export USER "$userpass"
    fi
  fi
  if [[ "$url" =~ ([^/]+)/(.*) ]]; then
    url="${url%%/*}"
    local path="${BASH_REMATCH[2]}"
    if [[ "$path" =~ \? ]]; then
      error "Hither URL doesn't support '?options' yet."
    fi
    set-export DBNAME "$path"
  fi
  if [[ "$url" =~ ^(.*):([0-9]{1,5})$ ]]; then
    set-export HOST "${BASH_REMATCH[1]}"
    set-export PORT "${BASH_REMATCH[2]}"
  else
    set-export HOST "$url"
  fi
}

set-export() {
  local var="HITHER_${in_out}_$1" val="$2"
  printf -v "$var" "$val"
  export "$var"
}

set-vars() {
  in="$HITHER_IN"
  out="$HITHER_OUT"
  to="$HITHER_TO"
  from="$HITHER_FROM"
  [ -n "$from" ] ||
    error "Can't determine FROM value. Try using '--from=…'."
  [ -n "$to" ] ||
    error "Can't determine TO value. Try using '--to=…'."
  [[ "$from" =~ ^(pg|my|lite|sql|csv)$ ]] ||
    error "Invalid FROM value: '$from'. Want 'pg|my|lite|sql|csv'."
  [[ "$to" =~ ^(pg|my|lite|hsd|sql|csv)$ ]] ||
    error "Invalid TO value: '$to'. Want 'pg|my|lite|hsd|sql|csv'."
}

check-profile() {
  if [ -n "$HITHER_PROFILE" ]; then
    [ -f "$HITHER_PROFILE" ] ||
      error "Profile '$HITHER_PROFILE' is not a file"
    source "$HITHER_PROFILE"
  fi
}

assert-command() {
  local missing=false
  local cmd
  for cmd in $@; do
    if ! $(type $cmd &> /dev/null); then
      echo "Required command not found: '$cmd'"
      missing=true
    fi
  done
  if "$missing"; then exit 1; fi
}

create-action-command() {
  command="hither-"
  if [ -n "$HITHER_ACTION" ]; then
    command+="$HITHER_ACTION-"
  fi
  command+="$HITHER_FROM-to-$HITHER_TO"
  if [ -n "$HITHER_WITH" ]; then
    command+="with-$HITHER_WITH"
  fi
}

[ "${BASH_SOURCE[0]}" != "$0" ] || main "$@"

# vim: set lisp:
